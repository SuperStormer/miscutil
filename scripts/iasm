#!/usr/bin/env python3
import ctypes
import re
import readline
import traceback

from keystone import KS_ARCH_X86, KS_MODE_64, Ks, KsError
from utils.hazmat.shellcode import run_shellcode

#ignore rbp and rsp
REG_NAMES = [
	"rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
]
FLAG_NAMES = {
	0: ("CF", "carry"),
	2: ("PF", "parity"),
	4: ("AF", "adjust"),
	6: ("ZF", "zero"),
	7: ("SF", "sign"),
	8: ("TF", "trap"),
	9: ("IF", "interrupt"),
	10: ("DF", "direction"),
	11: ("OF", "overflow"),
	14: ("NT", "nested_task"),
	16: ("RF", "resume"),
	17: ("VM", "virtual_x86"),
	18: ("AC", "alignment_check"),
	19: ("VIF", "virtual_interrupt"),
	20: ("VIP", "virtual_interrupt_pending"),
	21: ("ID", "cpuid")
}

def create_array(length):
	array = (ctypes.c_uint64 * length)()
	addr = ctypes.cast(array, ctypes.c_void_p).value
	return (array, addr)

class AsmRepl():
	def __init__(self, to_print=None, stack_size=128):
		if to_print is None:
			self.to_print = {"regs"}
		else:
			self.to_print = to_print
		self.stack_size = stack_size
		
		self.regs = {reg: 0 for reg in REG_NAMES}
		self.ks = Ks(KS_ARCH_X86, KS_MODE_64)
		self.libc = ctypes.CDLL("libc.so.6")
		
		self.reg_save, self.reg_save_addr = create_array(len(self.regs))
		self.stack, self.stack_addr = create_array(self.stack_size)
		self.rsp_save, self.rsp_save_addr = create_array(1)
		self.rbp_save, self.rbp_save_addr = create_array(1)
		self.flags, self.flags_addr = create_array(1)
		
		#4. save all the regs in the buffer
		#5. mov the saved rsp and rbp to rsp and rbp
		self.epilogue = self.ks.asm(
			"; ".join(
			f"mov rax, {reg}; mov [{self.reg_save_addr+i*8}], rax"
			for i, reg in enumerate(self.regs)
			) + f"; pushfq; pop rax; mov [{self.flags_addr}], rax; " +
			f"mov rax, [{self.rsp_save_addr}]; mov rsp, rax; " +
			f"mov rax, [{self.rbp_save_addr}]; mov rbp, rax; ret;",
			as_bytes=True
		)[0]
	
	def loop(self):
		while True:
			try:
				inp = input("iasm> ")
			except KeyboardInterrupt:
				print()
				continue
			if inp.startswith("!"):
				self.run_python(inp[1:])
			elif inp.startswith("set "):
				self.set_to_print(inp.split(" ")[1:])
			elif inp.startswith("reset ") or inp.startswith("clear "):
				self.clear_values(inp.split(" ")[1:])
			elif inp in ("exit", "quit"):
				return
			else:
				self.run(inp)
	
	def get_libc_address(self, func):
		return ctypes.cast(self.libc[func], ctypes.c_void_p).value
	
	def run_python(self, code):
		try:
			print(
				eval(code, {
				"stack": list(self.stack),
				"flags": list(self.flags),
				**self.regs
				}, {})
			)
		except Exception:
			traceback.print_exc()
	
	def set_to_print(self, values):
		"""add/remove values from to_print"""
		if not values:
			print("No arg provided")
			return
		if "all" in values:
			values = ["stack", "flags", "regs"]
		for val in values:
			if val.startswith("-"):
				if val[1:] in self.to_print:
					self.to_print.remove(val[1:])
				else:
					print(f"{val} not in to_print")
			else:
				self.to_print.add(val)
	
	def clear_values(self, values):
		if not values:
			print("No arg provided")
			return
		if "all" in values:
			values = ["stack", "regs"]
		for val in values:
			if val == "stack":
				self.stack = create_array(self.stack_size)
			elif val == "regs":
				self.regs = {reg: 0 for reg in REG_NAMES}
			else:
				print(f"Invalid value {val}")
	
	def print_vals(self):
		if "stack" in self.to_print:
			print(list(self.stack))
		flags = self.flags[0]
		if "flags_short" in self.to_print:
			print(" ".join(short for i, (short, _) in FLAG_NAMES.items() if flags & (1 << i)))
		if "flags" in self.to_print:
			print(" ".join(name for i, (_, name) in FLAG_NAMES.items() if flags & (1 << i)))
		if "regs" in self.to_print:
			print(self.regs)
	
	def assemble(self, asm):
		"""assemble into machine code"""
		#1. set rsp and rbp to the stack location and save the original rsp and rbp
		#2. mov all of the saved regs to the right spot
		code = self.ks.asm(
			"mov rbx, rsp; mov rcx, rbp;" +
			f"mov rbp, {self.stack_addr + len(self.stack) * 8}; mov rsp, rbp;" +
			f"mov rax, rbx; mov [{self.rsp_save_addr}], rax;" +
			f"mov rax, rcx; mov [{self.rbp_save_addr}], rax; " +
			"; ".join(f"mov {name}, {val}" for name, val in self.regs.items()),
			as_bytes=True
		)[0]
		#3. run the user input
		user_code = self.ks.asm(asm, as_bytes=True)[0]
		if user_code is not None:
			code += user_code
		#4. save all the regs in the buffer
		#5. mov the saved rsp and rbp to rsp and rbp
		code += self.epilogue
		return code
	
	def run(self, asm):
		"""run the assembly code"""
		#replace <func> with libc address
		try:
			asm = re.sub(r"<(\w+)>", lambda m: str(self.get_libc_address(m.group(1))), asm)
		except IndexError as e:
			print(e)
			return
		
		try:
			code = self.assemble(asm)
		except KsError as e:
			print(e)
			return
		if "code" in self.to_print:
			print(code)
		
		run_shellcode(code)
		self.regs = {reg: val for reg, val in zip(REG_NAMES, self.reg_save)}
		self.print_vals()

if __name__ == "__main__":
	import sys
	args = {"regs"}
	for arg in sys.argv[1:]:
		if arg.startswith("-") and arg[1:] in args:
			args.remove(arg[1:])
		else:
			args.add(arg)
	AsmRepl(args).loop()
